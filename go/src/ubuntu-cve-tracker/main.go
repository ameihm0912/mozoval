// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
// Contributor:
// - Aaron Meihm ameihm@mozilla.com
package main

import (
	"bufio"
	"encoding/xml"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"oval"
	"path"
	"regexp"
	"strings"
)

type cveEntry struct {
	cveID         string
	pkgName       string
	patchVersions map[string]string
}

var entries []cveEntry
var matchFilter *regexp.Regexp

func parseEntryFile(fpath string) (ret cveEntry) {
	const (
		_ = iota
		INNER_NONE
		INNER_PATCH
	)
	fd, err := os.Open(fpath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}
	defer func() {
		fd.Close()
	}()

	scanner := bufio.NewScanner(fd)
	parserMode := INNER_NONE
	curPkgName := ""
	ret.cveID = path.Base(fpath)
	ret.patchVersions = make(map[string]string)
	for scanner.Scan() {
		tokens := strings.Fields(scanner.Text())
		if len(tokens) == 0 {
			parserMode = INNER_NONE
			curPkgName = ""
			continue
		}

		if strings.HasPrefix(tokens[0], "Patches_") {
			parserMode = INNER_PATCH
			curPkgName = strings.TrimPrefix(tokens[0], "Patches_")
			curPkgName = strings.TrimRight(curPkgName, ":")
			ret.pkgName = curPkgName
			continue
		}

		if parserMode == INNER_PATCH {
			if len(tokens) < 2 {
				continue
			}
			idx := strings.Index(tokens[0], "_")
			if idx == -1 {
				continue
			}
			distname := tokens[0][:idx]
			if tokens[1] == "released" && len(tokens) > 2 {
				patchver := tokens[2]
				patchver = strings.Trim(patchver, "()")
				ret.patchVersions[distname] = patchver
			}
		}
	}
	if err = scanner.Err(); err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}

	return
}

func loadEntries(dirpath string) {
	dirents, err := ioutil.ReadDir(dirpath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}
	for _, i := range dirents {
		if !strings.HasPrefix(i.Name(), "CVE-") {
			continue
		}
		if matchFilter != nil {
			if !matchFilter.MatchString(i.Name()) {
				continue
			}
		}
		fname := path.Join(dirpath, i.Name())
		entries = append(entries, parseEntryFile(fname))
	}
}

func addDefinition(o *oval.GOvalDefinitions, prefix string, dist string, cve cveEntry) {
	// Create a state
	stateid := fmt.Sprintf("%v-state", prefix)
	state := oval.GDPKGInfoState{}
	state.ID = stateid
	state.EVRCheck.DataType = "evr_string"
	state.EVRCheck.Operation = "less than"
	state.EVRCheck.Value = cve.patchVersions[dist]

	// Create an object definition for the package
	objid := fmt.Sprintf("%v-object", prefix)
	obj := oval.GDPKGInfoObj{}
	obj.Name = cve.pkgName
	obj.ID = objid

	// Create a test
	testid := fmt.Sprintf("%v-test", prefix)
	test := oval.GDPKGInfoTest{}
	test.ID = testid
	test.Object.ObjectRef = objid
	test.State.StateRef = stateid

	// Create the new definition
	def := oval.GDefinition{}
	def.ID = prefix
	def.Class = "patch"

	criterion := oval.GCriterion{}
	criterion.Test = testid
	def.Criteria.Operator = "AND"
	def.Criteria.Criterion = append(def.Criteria.Criterion, criterion)

	o.Definitions.Definitions = append(o.Definitions.Definitions, def)
	o.States.DPKGInfoStates = append(o.States.DPKGInfoStates, state)
	o.Objects.DPKGInfoObjects = append(o.Objects.DPKGInfoObjects, obj)
	o.Tests.DPKGInfoTests = append(o.Tests.DPKGInfoTests, test)
}

func processEntries() {
	root := oval.GOvalDefinitions{}

	for i, ent := range entries {
		prefix := fmt.Sprintf("ubuntu-%v", i)
		for x := range ent.patchVersions {
			addDefinition(&root, prefix, x, ent)
		}
	}

	enc := xml.NewEncoder(os.Stdout)
	enc.Indent("", "  ")
	if err := enc.Encode(root); err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}
}

func main() {
	var fMatch string

	flag.StringVar(&fMatch, "i", "", "filter regexp")
	flag.Parse()
	args := flag.Args()
	if len(args) < 1 {
		fmt.Fprintf(os.Stderr, "specify path to ubuntu-cve-tracker directory\n")
		os.Exit(1)
	}

	fm, err := regexp.Compile(fMatch)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}
	matchFilter = fm

	entries = make([]cveEntry, 0)

	procdir := path.Join(args[0], "active")
	loadEntries(procdir)
	procdir = path.Join(args[0], "retired")
	loadEntries(procdir)
	processEntries()
}
